/*****************************************************************//**
 * \file   ConstantBuffer.h
 * \brief  定数バッファクラス
 * 
 * \author Hiroto Kuge
 * \date   October 2022
 *********************************************************************/
#pragma once

//=============================================================================
// ConstantBuffer Class
//=============================================================================
class ConstantBuffer{
	//-----------------------------------------------------------------------------
	// list of friend classes and methods.
	//-----------------------------------------------------------------------------
	//!{
			/* Nothing */
	//!} 
public:
	//-----------------------------------------------------------------------------
	// public variables.
	//-----------------------------------------------------------------------------
	//!{
			/* Nothing */
	//!} 
	//-----------------------------------------------------------------------------
	// public methods.
	//-----------------------------------------------------------------------------
	//!{
	/*****************************************************************//**
	 * \brief コンストラクタ
	 *********************************************************************/
	ConstantBuffer() {}
	
	/*****************************************************************//**
	 * \brief デストラクタ
	 *********************************************************************/
	~ConstantBuffer();

	/*****************************************************************//**
	 * \brief 初期化
	 *  
	 * \param size	  定数バッファ
	 * \param srcData 初期化データ
	 * 
	 * \memo 初期化データはフロントバッファバックバッファの両方にコピーされるので
	 *		 固定値を扱う定数バッファを作る場合はデータを渡すようにすること
	 *********************************************************************/
	void Init(size_t size, void* srcData = nullptr);
	
	/*****************************************************************//**
	 * \brief 利用可能かどうか判定
	 *  
	 * \return 
	 *********************************************************************/
	bool IsValid() const{
		return m_isValid;
	}
		
	/*****************************************************************//**
	 * \brief ディスクリプタヒープにCBVを登録
	 *  
	 * \param descriptorHandle	CPUディスクリプタハンドル
	 *********************************************************************/
	void RegistConstantBufferView(D3D12_CPU_DESCRIPTOR_HANDLE descriptorHandle);
	
	/*****************************************************************//**
	 * \brief ディスクリプタヒープにCBVを登録
	 *  
	 * \param descriptorHandle	CPUディスクリプタハンドル
	 * \param bufferNo			バッファ番号
	 *********************************************************************/
	void RegistConstantBufferView(D3D12_CPU_DESCRIPTOR_HANDLE descriptorHandle, int bufferNo);

	/*****************************************************************//**
	 * \brief VRAM(GPU側のメモリ)上の仮想アドレスを取得
	 *  
	 * \return VRAM(GPU側のメモリ)上の仮想アドレス
	 *********************************************************************/
	D3D12_GPU_VIRTUAL_ADDRESS GetGPUVirtualAddress();

	/*****************************************************************//**
	 * \brief	メモリマッピング済のポインタを取得
	 * 
	 * \return	メモリマッピング済のポインタ 
	 *********************************************************************/
	void* GetMappedPtr()const;

	template<typename T>
	T* GetMappedPtr(){
		return reinterpret_cast<T*>(GetMappedPtr());
	};

	/*****************************************************************//**
	 * \brief データをVRAM(GPU側)にコピー
	 * 
	 * \param data コピーデータ
	 *********************************************************************/
	void CopyToVRAM(void* data);

	template< class T>
	void CopyToVRAM(T& data){
		CopyToVRAM(&data);
	}
	//!}
private:
	//-----------------------------------------------------------------------------
	// private variables.
	//-----------------------------------------------------------------------------
	//!{
	 
	ComPtr<ID3D12Resource> m_pConstantBuffer[2] = { nullptr };	// 定数バッファ本体
	void* m_pConstBufferCPU[2] = { nullptr };					// CPU側からアクセスできる定数バッファのアドレス
	size_t m_size = 0;											// 定数バッファのサイズ(コピー時はこっちを使う)
	uint32_t m_allocSize = 0;									// アライメント済み割り当てサイズ
	bool m_isValid = false;										// 利用可能かどうか	

	//!}
	//-----------------------------------------------------------------------------
	// private methods.
	//-----------------------------------------------------------------------------
	//!{
			/* Nothing */
	//!} 
};

